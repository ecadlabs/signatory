# Azure setup

__Rough draft, needs polish and testing__

The goal of this guide is to configure Signatory to use a Azure KMS as a
singing backend. We will also show how to generate a new key inside the Azure
HSM, and how to "Bring Your Own Key"/"BYOK" by showing you how to import your
own key.

To setup Azure KMS as a signing backend for Signatory, you will need:

* An active Azure subscription
* The [Azure
CLI](https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest) `az`
installed and configured on your computer.


## Setup a new Azure Key Vault and credentials

Use the `signatory.yaml` signatory config file as a starting point.

You will need to create several Azure resources, and copy configuration into
the signatory config file. Let's begin.

This guide uses the `az` cli command to create all required resources.
For each command, you will get a json formatted result, or an error.

### Create a Azure resource group.

You need to specify the location you want your Signatory to be located. This is
up to you. The closer to your baker the better, but other criteria may be
important to you. In our example, we will use `canadaeast`, and we will call
our resource group "signatory_resgroup"

```sh
az group create \
    --name signatory_resgroup \
    --location canadaeast
```

Add your `resource_group` name to your signatory yaml configuration file.

### Create a new Key Vault, with HSM enabled

Next we will create a new Key Vault within our newly created resource_group.

We will call our Key Vault `signatory-keyvault`. You can add this name to your
signatory configuration file in `azure.vault`.

```sh
az keyvault create \
    --name signatory-keyvault \
    --resource-group signatory_resgroup \
    --sku premium
```

The `--sku` argument must be set to premium if you want to have your keys
stored in a HSM.

### Get the subscription and tenant id for your account

To find your subscription id, run the command;

```sh
az account list
```

Copy the `id` value (this is your `subscription` id) and the `tenant_id` values
from the json output, and put them into your configuration file.

If you have multiple logins configured for your `az` command, make sure to
choose the correct one.

### Create a Service Principal for authentication

Next we need to create a "service principal" resource (also known as a "service
account" or a "App Registration").

This is the credential that allows Signatory to authenticate and work with the
Azure KMS service.

Run the command:

```sh
az ad sp create-for-rbac --name "signatory_serviceprincipal"
```

* Copy the `name` value (`signatory_serviceprincipal`) prefix into the `client_id` property under your new azure config block. Add `http://` to the beginning, so it looks like `client_id: http://signatory_serviceprincipal`
* Copy the `password` value into the `client_secret` property
* Copy the value of `appId` for use in the next command

Next we need to grant the new "service principal" access to our Key Vault. You
need to use the `appId` value from the previous command to do this.

```sh
 az keyvault set-policy \
    --name signatory-keyvault \
    --spn APPID_FROM_PREVIOUS_COMMAND \
    --key-permissions sign list get import
```

## Import a key to Azure

*Coming Soon*

## Generate a key in Azures HSM

You can generate a key pair within the HSM.

*WARNING* 

This key is not exportable, so you do not have portability. If you use a
private key generated by the Azure HSM, you are locked into using Azure for all
signing operations. This might be good in some aspects, such as surety,
plausible deniability, etc. but your if you loose access to your Azure account,
or accidentally delete you Key Vault you loose access to your key and any assets assocaited with your account. 

*PROCEED WITH CAUTION*. We recommend to use this approach only for testing.

To generate a new key in the HSM, you use the command below. You can choose to
type of Tezos address by specifying the curve to use.

* `--curve P-256` will generate a `tz3` address
* `--curve P-256K` will generate a `tz2` address

```
az keyvault key create --name sigtestkey2 --vault-name sigtest2 --protection hsm --kty EC-HSM --curve P-256
```

The output from this command will show you a value similar to:

```
kid: https://sigtest2.vault.azure.net/keys/sigtestkey2/1757975528b04c488c36963eee6e9d5d
```

You need to copy, edit and add this URL to your configuration as follows;

* Copy the URL portion `https://sigtest2.vault.azure.net/keys/sigtestkey2/1757975528b04c488c36963eee6e9d5d`
* Remove the last part of the path so you get: `https://sigtest2.vault.azure.net/keys/sigtestkey2`
* Copy this URL into the keys list of your signatory configuration


When you start signatory, it will connect to azure, request the public key
co-ordinates using the `kid` URL, and print the `tz` address to the console.

When you see the `tz` address, you must copy this value into the `tezos.keys`
list for Signatory to carry out signing operations using this address.

## Testing / Verify

To test the signing operation, you can send a post to signatory. In this
example, we are sending a dummy operation of type `02`, which is a `endorsement`
operation type. 

```sh
curl -XPOST \
    -d '"02111111111111111111"' \
    localhost:8003/keys/tz3Tm6UTWmPAZJaNSPAQNiMiyFSHnRXrkcHj
```

If you receive an error from curl and on the signatory console, you will have
to investigate. If it was successful, you should see output similar to:

```
{"signature":"p2sigR4JTRTMkT4XC4NgVuGdhZDbgaaSZpNPUserkyMCTY1GQJTFpCuihFRVk9n7YaNjA5U3cNcvJPRm7C9G5A1hsLsesVPcMu"}
```
